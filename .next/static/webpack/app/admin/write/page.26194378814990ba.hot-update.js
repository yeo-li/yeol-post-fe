"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/write/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deletePost: () => (/* binding */ deletePost),\n/* harmony export */   fetchAboutMe: () => (/* binding */ fetchAboutMe),\n/* harmony export */   fetchAllDraftPosts: () => (/* binding */ fetchAllDraftPosts),\n/* harmony export */   fetchAllPosts: () => (/* binding */ fetchAllPosts),\n/* harmony export */   fetchCategoriesAndPostsCount: () => (/* binding */ fetchCategoriesAndPostsCount),\n/* harmony export */   fetchCategoriesRecent: () => (/* binding */ fetchCategoriesRecent),\n/* harmony export */   fetchDeleteCategory: () => (/* binding */ fetchDeleteCategory),\n/* harmony export */   fetchDraft: () => (/* binding */ fetchDraft),\n/* harmony export */   fetchHistories: () => (/* binding */ fetchHistories),\n/* harmony export */   fetchInterests: () => (/* binding */ fetchInterests),\n/* harmony export */   fetchLoginInformation: () => (/* binding */ fetchLoginInformation),\n/* harmony export */   fetchPost: () => (/* binding */ fetchPost),\n/* harmony export */   fetchPublishDraftPost: () => (/* binding */ fetchPublishDraftPost),\n/* harmony export */   fetchRecentPosts: () => (/* binding */ fetchRecentPosts),\n/* harmony export */   fetchSaveCategory: () => (/* binding */ fetchSaveCategory),\n/* harmony export */   fetchSaveDraftPost: () => (/* binding */ fetchSaveDraftPost),\n/* harmony export */   fetchSavePost: () => (/* binding */ fetchSavePost),\n/* harmony export */   fetchStatics: () => (/* binding */ fetchStatics),\n/* harmony export */   fetchUpdateCategory: () => (/* binding */ fetchUpdateCategory),\n/* harmony export */   fetchUpdateDraftPost: () => (/* binding */ fetchUpdateDraftPost),\n/* harmony export */   fetchUpdatePost: () => (/* binding */ fetchUpdatePost)\n/* harmony export */ });\n/* harmony import */ var _src_config_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/config.ts */ \"(app-pages-browser)/./src/config.ts\");\n\nasync function fetchLoginInformation() {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/admins/me\"), {\n            credentials: 'include'\n        });\n        const data = await response.json();\n        if (data.isLoggedIn) {\n            return {\n                isLoggedIn: true,\n                user: data\n            };\n        } else {\n            return {\n                isLoggedIn: false\n            };\n        }\n    } catch (err) {\n        console.error('에러 발생:', err);\n    }\n}\nasync function fetchUpdatePost(postId, data) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts/\").concat(postId), {\n            method: \"PATCH\",\n            credentials: \"include\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            return await response.json();\n        } else {\n            return {\n                success: true,\n                message: \"게시물이 성공적으로 업데이트되었습니다.\"\n            };\n        }\n    } catch (err) {\n        console.error(\"게시글 수정 실패:\", err);\n        throw err;\n    }\n}\nasync function fetchUpdateDraftPost(postId, data) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/drafts/\").concat(postId), {\n            method: \"PATCH\",\n            credentials: \"include\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            return await response.json();\n        } else {\n            return {\n                success: true,\n                message: \"게시물이 성공적으로 업데이트되었습니다.\"\n            };\n        }\n    } catch (err) {\n        console.error(\"게시글 수정 실패:\", err);\n        throw err;\n    }\n}\nasync function fetchRecentPosts() {\n    // 본문 제외 모든 정보가 필요함.\n    // 최근 6개의 글만 가져오기\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts?limit=6&is_published=true\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        console.log(json);\n        return json;\n    } catch (err) {\n        console.error('게시글 불러오기 실패:', err);\n        return [];\n    }\n}\nasync function fetchCategoriesAndPostsCount() {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/categories\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        return json.result;\n    } catch (err) {\n        console.error('카테고리 불러오기 실패:', err);\n        return [];\n    }\n/**\n     {\n     “total_categories_count”: 4\n     “categories”: [\n     {\n     “category_id”: 1,\n     “category_name”: “개발”,\n     “post_count”: 8\n     },\n     ]\n     }\n     */ }\nasync function fetchPost(param) {\n    let { postId } = param;\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        return json.result.find((post)=>Number(post.postId) === Number(postId));\n    } catch (err) {\n        console.error('게시글 불러오기 실패:', err);\n        return [];\n    }\n}\nasync function fetchDraft(param) {\n    let { postId } = param;\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/drafts\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        return json.result.find((post)=>Number(post.postId) === Number(postId));\n    } catch (err) {\n        console.error('임시 저장 게시글 불러오기 실패:', err);\n        return [];\n    }\n}\nasync function fetchAllPosts() {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts?is_published=true\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 불러오기 실패:', err);\n        return [];\n    }\n}\nasync function fetchAllDraftPosts() {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/drafts\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 불러오기 실패:', err);\n        return [];\n    }\n}\nasync function fetchCategoriesRecent() {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/categories/recent\"), {\n            method: 'GET',\n            credentials: 'include'\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 불러오기 실패:', err);\n        return [];\n    }\n/*\n    [\n        {\n\t\t“category_id”: 1,\n\t\t“category_name”: “개발”,\n“category_description”: “웹 개발, 프로그래밍 언어, 프레임워크 등… ”,\n“post_count”: 8,\n\t\t“recent_post”: {\n    “post_id”: 1,\n\t\t\t“title”: “React 18의 새로운 기능들 살펴보기”,\n    “published_at”: 2025-22-23\n    }\n},\n]\n    */ }\nasync function fetchAboutMe() {\n/*\n    {\n\t“”about_me”: “안녕하세요~ 박성열입니다.”\n}\n     */ }\nasync function fetchInterests() {\n/*\n    [\n\t{\n\t\t“tech”: “React”,\n\t\t“level”: “중급”\n\t},\n]\n     */ }\nasync function fetchHistories() {\n/*\n    [\n\t{\n\t\t“title”: “백엔드 개발자”,\n\t\t“start_date”: 2022-05-22,\n\t\t“end_date”: null,\n\t\t“description”: “React, Next.js를 사용한 웹 애플리케이션 개발”\n\t},\n]\n     */ }\nasync function fetchStatics() {\n/*\n    {\n\t“total_post_count”: 28,\n\t“total_categories_count”: 4\n}\n     */ }\nasync function fetchSavePost(data) {\n    try {\n        console.log(data);\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts\"), {\n            method: 'POST',\n            credentials: 'include',\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 저장 실패:', err);\n        return [];\n    }\n}\nasync function fetchSaveCategory(data) {\n    try {\n        console.log(data);\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/categories\"), {\n            method: 'POST',\n            credentials: 'include',\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('카테고리 저장 실패:', err);\n        return [];\n    }\n}\nasync function fetchSaveDraftPost(data) {\n    try {\n        console.log(data);\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/drafts\"), {\n            method: 'POST',\n            credentials: 'include',\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 저장 실패:', err);\n        return [];\n    }\n}\nasync function deletePost(postId) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/posts/\").concat(postId), {\n            method: \"DELETE\",\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        // DELETE 요청은 보통 응답 본문이 없거나 간단한 상태만 반환\n        // 응답이 있다면 JSON으로 파싱, 없다면 성공 객체 반환\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const json = await response.json();\n            return json;\n        } else {\n            return {\n                success: true,\n                message: \"게시물이 성공적으로 삭제되었습니다.\"\n            };\n        }\n    } catch (err) {\n        console.error(\"게시글 삭제 실패:\", err);\n        throw err;\n    }\n}\nasync function fetchPublishDraftPost(postId) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/drafts/\").concat(postId, \"/publish\"), {\n            method: 'POST',\n            credentials: 'include',\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        const json = await response.json();\n        console.log(json.result);\n        return json.result;\n    } catch (err) {\n        console.error('게시글 저장 실패:', err);\n        return [];\n    }\n}\nasync function fetchDeleteCategory(categoryId) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/categories/\").concat(categoryId), {\n            method: \"DELETE\",\n            credentials: \"include\"\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        // DELETE 요청은 보통 응답 본문이 없거나 간단한 상태만 반환\n        // 응답이 있다면 JSON으로 파싱, 없다면 성공 객체 반환\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            const json = await response.json();\n            return json;\n        } else {\n            return {\n                success: true,\n                message: \"게시물이 성공적으로 삭제되었습니다.\"\n            };\n        }\n    } catch (err) {\n        console.error(\"게시글 삭제 실패:\", err);\n        throw err;\n    }\n}\nasync function fetchUpdateCategory(categoryId, data) {\n    try {\n        const response = await fetch(\"\".concat(_src_config_ts__WEBPACK_IMPORTED_MODULE_0__.API_URL, \"/api/v1/categories/\").concat(categoryId), {\n            method: \"PATCH\",\n            credentials: \"include\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n            return await response.json();\n        } else {\n            return {\n                success: true,\n                message: \"카테고리가 성공적으로 업데이트되었습니다.\"\n            };\n        }\n    } catch (err) {\n        console.error(\"카테고리 수정 실패:\", err);\n        throw err;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUMsTUFBTSxHQUFnQytDLE9BQTdCbEQsbURBQU9BLEVBQUMsdUJBQWdDLE9BQVhrRCxhQUFjO1lBQ3ZFcEMsUUFBUTtZQUNSVixhQUFhO1lBQ2JXLFNBQVM7Z0JBQ0wsZ0JBQWdCO1lBQ3BCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ2I7UUFDekI7UUFDQSxJQUFJLENBQUNILFNBQVNpQixFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlDLE1BQU0sdUJBQXVDLE9BQWhCbEIsU0FBU21CLE1BQU07UUFDMUQ7UUFDQSxNQUFNQyxjQUFjcEIsU0FBU2EsT0FBTyxDQUFDUSxHQUFHLENBQUM7UUFDekMsSUFBSUQsZUFBZUEsWUFBWUUsUUFBUSxDQUFDLHFCQUFxQjtZQUN6RCxPQUFPLE1BQU10QixTQUFTSSxJQUFJO1FBQzlCLE9BQU87WUFDSCxPQUFPO2dCQUFFbUIsU0FBUztnQkFBTUMsU0FBUztZQUF5QjtRQUM5RDtJQUNKLEVBQUUsT0FBT2pCLEtBQUs7UUFDVkMsUUFBUUMsS0FBSyxDQUFDLGVBQWVGO1FBQzdCLE1BQU1BO0lBQ1Y7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3llb2xpL2dpdC95ZW9sLXBvc3QtZmUvbGliL2FwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUElfVVJMIH0gZnJvbSAnLi4vc3JjL2NvbmZpZy50cyc7XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG9naW5JbmZvcm1hdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9hZG1pbnMvbWVgLCB7XG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoZGF0YS5pc0xvZ2dlZEluKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc0xvZ2dlZEluOiB0cnVlLCB1c2VyOiBkYXRhIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge2lzTG9nZ2VkSW46IGZhbHNlfTtcbiAgICAgICAgfVxuXG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign7JeQ65+sIOuwnOyDnTonLCBlcnIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVXBkYXRlUG9zdChwb3N0SWQ6IG51bWJlciwgZGF0YTogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvcG9zdHMvJHtwb3N0SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIuqyjOyLnOusvOydtCDshLHqs7XsoIHsnLzroZwg7JeF642w7J207Yq465CY7JeI7Iq164uI64ukLlwiIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuqyjOyLnOq4gCDsiJjsoJUg7Iuk7YyoOlwiLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVcGRhdGVEcmFmdFBvc3QocG9zdElkOiBudW1iZXIsIGRhdGE6IGFueSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2RyYWZ0cy8ke3Bvc3RJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IFwi6rKM7Iuc66y87J20IOyEseqzteyggeycvOuhnCDsl4XrjbDsnbTtirjrkJjsl4jsirXri4jri6QuXCIgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi6rKM7Iuc6riAIOyImOyglSDsi6TtjKg6XCIsIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFJlY2VudFBvc3RzKCkge1xuICAgIC8vIOuzuOusuCDsoJzsmbgg66qo65OgIOygleuztOqwgCDtlYTsmpTtlaguXG4gICAgLy8g7LWc6re8IDbqsJzsnZgg6riA66eMIOqwgOyguOyYpOq4sFxuICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvcG9zdHM/bGltaXQ9NiZpc19wdWJsaXNoZWQ9dHJ1ZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb24pO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgY29uc29sZS5lcnJvcign6rKM7Iuc6riAIOu2iOufrOyYpOq4sCDsi6TtjKg6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ2F0ZWdvcmllc0FuZFBvc3RzQ291bnQoKSB7XG4gICAgdHJ5e1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9jYXRlZ29yaWVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGpzb24ucmVzdWx0O1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgICBjb25zb2xlLmVycm9yKCfsubTthYzqs6Drpqwg67aI65+s7Jik6riwIOyLpO2MqDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICB7XG4gICAgIOKAnHRvdGFsX2NhdGVnb3JpZXNfY291bnTigJ06IDRcbiAgICAg4oCcY2F0ZWdvcmllc+KAnTogW1xuICAgICB7XG4gICAgIOKAnGNhdGVnb3J5X2lk4oCdOiAxLFxuICAgICDigJxjYXRlZ29yeV9uYW1l4oCdOiDigJzqsJzrsJzigJ0sXG4gICAgIOKAnHBvc3RfY291bnTigJ06IDhcbiAgICAgfSxcbiAgICAgXVxuICAgICB9XG4gICAgICovXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFBvc3Qoe3Bvc3RJZH06IHsgcG9zdElkOiBudW1iZXIgfSkge1xuICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvcG9zdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJ1xuICAgICAgICB9KVxuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4ganNvbi5yZXN1bHQuZmluZCgocG9zdDogYW55KSA9PiBOdW1iZXIocG9zdC5wb3N0SWQpID09PSBOdW1iZXIocG9zdElkKSk7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+qyjOyLnOq4gCDrtojrn6zsmKTquLAg7Iuk7YyoOicsIGVycik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERyYWZ0KHtwb3N0SWR9OiB7IHBvc3RJZDogbnVtYmVyIH0pIHtcbiAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2RyYWZ0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBqc29uLnJlc3VsdC5maW5kKChwb3N0OiBhbnkpID0+IE51bWJlcihwb3N0LnBvc3RJZCkgPT09IE51bWJlcihwb3N0SWQpKTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgY29uc29sZS5lcnJvcign7J6E7IucIOyggOyepSDqsozsi5zquIAg67aI65+s7Jik6riwIOyLpO2MqDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbGxQb3N0cygpIHtcbiAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL3Bvc3RzP2lzX3B1Ymxpc2hlZD10cnVlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coanNvbi5yZXN1bHQpO1xuICAgICAgICByZXR1cm4ganNvbi5yZXN1bHQ7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+qyjOyLnOq4gCDrtojrn6zsmKTquLAg7Iuk7YyoOicsIGVycik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFsbERyYWZ0UG9zdHMoKSB7XG4gICAgdHJ5e1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9kcmFmdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJ1xuICAgICAgICB9KVxuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhqc29uLnJlc3VsdCk7XG4gICAgICAgIHJldHVybiBqc29uLnJlc3VsdDtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgY29uc29sZS5lcnJvcign6rKM7Iuc6riAIOu2iOufrOyYpOq4sCDsi6TtjKg6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDYXRlZ29yaWVzUmVjZW50KCkge1xuICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2F0ZWdvcmllcy9yZWNlbnRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJ1xuICAgICAgICB9KVxuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhqc29uLnJlc3VsdCk7XG4gICAgICAgIHJldHVybiBqc29uLnJlc3VsdDtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgY29uc29sZS5lcnJvcign6rKM7Iuc6riAIOu2iOufrOyYpOq4sCDsi6TtjKg6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKlxuICAgIFtcbiAgICAgICAge1xuXHRcdOKAnGNhdGVnb3J5X2lk4oCdOiAxLFxuXHRcdOKAnGNhdGVnb3J5X25hbWXigJ06IOKAnOqwnOuwnOKAnSxcbuKAnGNhdGVnb3J5X2Rlc2NyaXB0aW9u4oCdOiDigJzsm7kg6rCc67CcLCDtlITroZzqt7jrnpjrsI0g7Ja47Ja0LCDtlITroIjsnoTsm4ztgawg65Ox4oCmIOKAnSxcbuKAnHBvc3RfY291bnTigJ06IDgsXG5cdFx04oCccmVjZW50X3Bvc3TigJ06IHtcbiAgICDigJxwb3N0X2lk4oCdOiAxLFxuXHRcdFx04oCcdGl0bGXigJ06IOKAnFJlYWN0IDE47J2YIOyDiOuhnOyatCDquLDriqXrk6Qg7IK07Y6067O06riw4oCdLFxuICAgIOKAnHB1Ymxpc2hlZF9hdOKAnTogMjAyNS0yMi0yM1xuICAgIH1cbn0sXG5dXG4gICAgKi9cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQWJvdXRNZSgpIHtcbiAgICAvKlxuICAgIHtcblx04oCc4oCdYWJvdXRfbWXigJ06IOKAnOyViOuFle2VmOyEuOyalH4g67CV7ISx7Je07J6F64uI64ukLuKAnVxufVxuICAgICAqL1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hJbnRlcmVzdHMoKSB7XG4gICAgLypcbiAgICBbXG5cdHtcblx0XHTigJx0ZWNo4oCdOiDigJxSZWFjdOKAnSxcblx0XHTigJxsZXZlbOKAnTog4oCc7KSR6riJ4oCdXG5cdH0sXG5dXG4gICAgICovXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEhpc3RvcmllcygpIHtcbiAgICAvKlxuICAgIFtcblx0e1xuXHRcdOKAnHRpdGxl4oCdOiDigJzrsLHsl5Trk5wg6rCc67Cc7J6Q4oCdLFxuXHRcdOKAnHN0YXJ0X2RhdGXigJ06IDIwMjItMDUtMjIsXG5cdFx04oCcZW5kX2RhdGXigJ06IG51bGwsXG5cdFx04oCcZGVzY3JpcHRpb27igJ06IOKAnFJlYWN0LCBOZXh0Lmpz66W8IOyCrOyaqe2VnCDsm7kg7JWg7ZSM66as7LyA7J207IWYIOqwnOuwnOKAnVxuXHR9LFxuXVxuICAgICAqL1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTdGF0aWNzKCkge1xuICAgIC8qXG4gICAge1xuXHTigJx0b3RhbF9wb3N0X2NvdW504oCdOiAyOCxcblx04oCcdG90YWxfY2F0ZWdvcmllc19jb3VudOKAnTogNFxufVxuICAgICAqL1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTYXZlUG9zdChkYXRhOiBhbnkpIHtcbiAgICB0cnl7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9wb3N0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb24ucmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIGpzb24ucmVzdWx0O1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgICBjb25zb2xlLmVycm9yKCfqsozsi5zquIAg7KCA7J6lIOyLpO2MqDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTYXZlQ2F0ZWdvcnkoZGF0YTogYW55KSB7XG4gICAgdHJ5e1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2F0ZWdvcmllc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb24ucmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIGpzb24ucmVzdWx0O1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgICBjb25zb2xlLmVycm9yKCfsubTthYzqs6Drpqwg7KCA7J6lIOyLpO2MqDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTYXZlRHJhZnRQb3N0KGRhdGE6IGFueSkge1xuICAgIHRyeXtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2RyYWZ0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb24ucmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIGpzb24ucmVzdWx0O1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgICBjb25zb2xlLmVycm9yKCfqsozsi5zquIAg7KCA7J6lIOyLpO2MqDonLCBlcnIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlUG9zdChwb3N0SWQ6IG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL3Bvc3RzLyR7cG9zdElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERFTEVURSDsmpTssq3snYAg67O07Ya1IOydkeuLtSDrs7jrrLjsnbQg7JeG6rGw64KYIOqwhOuLqO2VnCDsg4Htg5zrp4wg67CY7ZmYXG4gICAgICAgIC8vIOydkeuLteydtCDsnojri6TrqbQgSlNPTuycvOuhnCDtjIzsi7EsIOyXhuuLpOuptCDshLHqs7Ug6rCd7LK0IOuwmO2ZmFxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgIHJldHVybiBqc29uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIuqyjOyLnOusvOydtCDshLHqs7XsoIHsnLzroZwg7IKt7KCc65CY7JeI7Iq164uI64ukLlwiIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi6rKM7Iuc6riAIOyCreygnCDsi6TtjKg6XCIsIGVycilcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQdWJsaXNoRHJhZnRQb3N0KHBvc3RJZDogbnVtYmVyKSB7XG4gICAgdHJ5e1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2FwaS92MS9kcmFmdHMvJHtwb3N0SWR9L3B1Ymxpc2hgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coanNvbi5yZXN1bHQpO1xuICAgICAgICByZXR1cm4ganNvbi5yZXN1bHQ7XG4gICAgfWNhdGNoKGVycil7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+qyjOyLnOq4gCDsoIDsnqUg7Iuk7YyoOicsIGVycik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERlbGV0ZUNhdGVnb3J5KGNhdGVnb3J5SWQ6IG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYXBpL3YxL2NhdGVnb3JpZXMvJHtjYXRlZ29yeUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERFTEVURSDsmpTssq3snYAg67O07Ya1IOydkeuLtSDrs7jrrLjsnbQg7JeG6rGw64KYIOqwhOuLqO2VnCDsg4Htg5zrp4wg67CY7ZmYXG4gICAgICAgIC8vIOydkeuLteydtCDsnojri6TrqbQgSlNPTuycvOuhnCDtjIzsi7EsIOyXhuuLpOuptCDshLHqs7Ug6rCd7LK0IOuwmO2ZmFxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgIHJldHVybiBqc29uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIuqyjOyLnOusvOydtCDshLHqs7XsoIHsnLzroZwg7IKt7KCc65CY7JeI7Iq164uI64ukLlwiIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwi6rKM7Iuc6riAIOyCreygnCDsi6TtjKg6XCIsIGVycilcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgfVxufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFVwZGF0ZUNhdGVnb3J5KGNhdGVnb3J5SWQ6IG51bWJlciwgZGF0YTogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hcGkvdjEvY2F0ZWdvcmllcy8ke2NhdGVnb3J5SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIuy5tO2FjOqzoOumrOqwgCDshLHqs7XsoIHsnLzroZwg7JeF642w7J207Yq465CY7JeI7Iq164uI64ukLlwiIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuy5tO2FjOqzoOumrCDsiJjsoJUg7Iuk7YyoOlwiLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufSJdLCJuYW1lcyI6WyJBUElfVVJMIiwiZmV0Y2hMb2dpbkluZm9ybWF0aW9uIiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiZGF0YSIsImpzb24iLCJpc0xvZ2dlZEluIiwidXNlciIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImZldGNoVXBkYXRlUG9zdCIsInBvc3RJZCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJjb250ZW50VHlwZSIsImdldCIsImluY2x1ZGVzIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJmZXRjaFVwZGF0ZURyYWZ0UG9zdCIsImZldGNoUmVjZW50UG9zdHMiLCJsb2ciLCJmZXRjaENhdGVnb3JpZXNBbmRQb3N0c0NvdW50IiwicmVzdWx0IiwiZmV0Y2hQb3N0IiwiZmluZCIsInBvc3QiLCJOdW1iZXIiLCJmZXRjaERyYWZ0IiwiZmV0Y2hBbGxQb3N0cyIsImZldGNoQWxsRHJhZnRQb3N0cyIsImZldGNoQ2F0ZWdvcmllc1JlY2VudCIsImZldGNoQWJvdXRNZSIsImZldGNoSW50ZXJlc3RzIiwiZmV0Y2hIaXN0b3JpZXMiLCJmZXRjaFN0YXRpY3MiLCJmZXRjaFNhdmVQb3N0IiwiZmV0Y2hTYXZlQ2F0ZWdvcnkiLCJmZXRjaFNhdmVEcmFmdFBvc3QiLCJkZWxldGVQb3N0IiwiZmV0Y2hQdWJsaXNoRHJhZnRQb3N0IiwiZmV0Y2hEZWxldGVDYXRlZ29yeSIsImNhdGVnb3J5SWQiLCJmZXRjaFVwZGF0ZUNhdGVnb3J5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_URL: () => (/* binding */ API_URL)\n/* harmony export */ });\nconst API_URL = \"https:/api.yeo-li.com\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMveWVvbGkvZ2l0L3llb2wtcG9zdC1mZS9zcmMvY29uZmlnLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBUElfVVJMID0gXCJodHRwczovYXBpLnllby1saS5jb21cIjsiXSwibmFtZXMiOlsiQVBJX1VSTCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config.ts\n"));

/***/ })

});